
* Using this file
  This README file was produced for processing by Emacs org-mode for
  publishing, for literate-programming of examples, for bug-tracking
  and task/issue management, etc.

  (leveraging ORG-MODE tools for mixing in TODO's within docs -- need
  to include incantation for this to do the right thing for the agenda
  view!
** TODO [#A] Write up basic description for using this file!
   - State "TODO"       from ""           [2010-06-07 Mon 16:18]
#+begin_src emacs-lisp
  ;; code for using this and the in-lined commented TODOs
  ;; of course, still must be written
#+end_src
* Credits
  Original Idea and majority (all?) work:  Tamas K. Papp <tkpapp@gmail.com>
  Mucking, cleaning, simplifying: AJ Rossini <blindglobe@gmail.com>
* Overview
  This package implements a generalized interface for array-like
  objects.  An array-like object is any structure whose data (but not
  necessarily metadata) could be mappable to either a lisp array or a
  list-of-list structure.  The idea is that we should be able to index
  an object's data, but might not be able to access specialized
  metadata.   The primary generic function is: 
#+begin_src
  (xref object #| 1 2 3 or other things that reference objects |# )
#+end_src
  to retrieve or set an element.  This would be easy to do it aref was
  a generic function, but it is not.  I (Tamas) describe a simple
  interface with a few generic functions.  Any objects that has these
  methods is called "xrefable".  For a given datastructure, we must
  implement the following tools.
** XDIMS
   queries dimensions of structure
#+begin_src common-lisp
(xdims object) 
#+end_src
** XTYPE
#+begin_src common-lisp
   (xtype object &optional <ref>)
#+end_src
   queries element and substructure types.  If <ref> is given, it
   returns the substructure, if <ref> is nil, it returns the whole
   structure. 
** XREF
#+begin_src common-lisp
   (xref object <ref>)
#+end_src
   queries (sub)structure and returns views which can be accessed and
   set.  The reference <ref> manages to 
** XCOPY
#+begin_src common-lisp
   (xcopy object <ref>)
#+end_src
   queries (sub)structure and returns copies.  If one gets confused
   between a view and copy, dire consequences could entail, so we use
   separate generic functions for reference and copy, rather than a
   single "xaccess", which could result in:
#+begin_src common-lisp
   (defmacro xref  (&rest args) (xaccess :type 'reference @args))
   (defmacro xcopy (&rest args) (xaccess :type 'copy      @args))
#+end_src
** XNEW
   creates a new structure.  One could consider using a undefined
   object in order to implement this with setf, i.e. 
#+begin_src common-lisp
   (setf (xref undef-object <refs>) object-with-right-structure)
#+end_src
   and having it return undef-object with the right value.

* Approach in general

  Both copies and views on an array should be XREF-able.  

  Example: For an two-dimensional array *a*,

#+begin_src common-lisp
  (slice *a* :all 4)
#+end_src

  selects the 4th column of an array.[1] This view is also xrefable,
  so you can use

#+begin_src common-lisp
  (setf (xref (slice *a* :all 4) 2) 9)
#+end_src

  to set element 2 to 9.  Changes will be made in the original array
#+begin_src common-lisp
  *a*
#+end_src
  since this is a view.  But for functions that just expect an array,
  they can use the interface (xref, xdims, etc) and not care where it
  is coming from.

  I have also implemented permutations (generalized transpose), and
  row-major projections.  If you want to collect the elements of a
  view in an array, use
#+begin_src common-lisp
  (take object)
#+end_src

  which delivers a CL array.

  There are convenience functions that for easy array/vector creation,
  inspired by R:

#+begin_src common-lisp
  (carray* '(2 3) 1 2 3 4d0 5 6)
  ;; => #2A((1.0d0 2.0d0 3.0d0) (4.0d0 5.0d0 6.0d0))
#+end_src

  guess the type so that all of the elements would fit in.  See also
  cvector and carray (manually specified type) and cvector*.

* Roadmap, tasks, bugs.
** TODO [#B] unit testing [0/5]
   - State "TODO"       from ""           [2010-06-07 Mon 15:33]
*** TODO [#B] XDIMS unittests
    - State "TODO"       from ""           [2010-06-07 Mon 15:29]
*** TODO [#B] XTYPE unittests
    - State "TODO"       from ""           [2010-06-07 Mon 15:29]
*** TODO [#B] XREF unittests
    - State "TODO"       from ""           [2010-06-07 Mon 15:29]
*** TODO [#B] XCOPY unittests
    - State "TODO"       from ""           [2010-06-07 Mon 15:29]
*** TODO [#B] XNEW unittests
    - State "TODO"       from ""           [2010-06-07 Mon 15:29]
** TODO [#A] integrate linear algebra routines
   - State "TODO"       from ""           [2010-06-07 Mon 15:33]
   probably from GSLL?  It should
   be easy to rig an xrefable interface to GSLL arrays.
** TODO [#B] Specialized arrays [0/2]
   - State "TODO"       from ""           [2010-06-07 Mon 15:33]
   upper- and lower-triangular matrices, etc.  xrefable elements can
   be read-only, xref-writeable-p is an interface to test if an
   element is writeable, it was included specifically for this.
   In addition, integrate sparse matrices from cl-sparsematrix.
*** TODO [#B] Triangular matrices
    - State "TODO"       from ""           [2010-06-07 Mon 15:33]
*** TODO [#B] Sparse matrices
    - State "TODO"       from ""           [2010-06-07 Mon 15:33]
** TODO [#B] specialized subclasses for certain cases and operations
   - State "TODO"       from ""           [2010-06-07 Mon 15:34]
   eg views on matrices, a transpose-view would be much simpler (and
   faster, maybe?) than the generalized permute.  Some operations (such as
   outer products, multiplication, addition) could be highly optimized
   when we know more about the specific structure (e.g. triangular,
   only ones/zeros, etc...).
** TODO [#B] decent printing for xrefable objects,
   - State "TODO"       from ""           [2010-06-07 Mon 15:34]
   currently converted to array.
** TODO [#B] direct access from other systems
   - State "TODO"       from ""           [2010-06-07 Mon 15:34]
   certain views can be directly accommodated by LAPACK/GSLL (eg a
   matrix with a stride).  Minor possibility for speedup/memory
   savings.  This is related to optimization based on substructure. 
** TODO [#B] fix SLICE api between LISP-MATRIX and XARRAY
   - State "TODO"       from ""           [2010-06-07 Mon 15:38]
** TODO [#B] implement equalp for XREF-able objects
   - State "TODO"       from ""           [2010-06-07 Mon 15:40]
* Development in progress
  To use this from within org-mode/org-babel, C-c ' will put into
  slime / lisp editing mode
#+begin_src common-lisp
  (in-package :cl-user)
  (asdf:oos 'asdf:compile-op 'xarray :force t)
  (asdf:oos 'asdf:load-op 'xarray)
  (asdf:oos 'asdf:load-op 'xarray-test)
#+end_src
  Tamas was thinking about this being a general interface, but then in
  my (Tony's) opinion, included some specialized issues that needed to
  be considered here but handled elsewhere.  My limited understanding
  had to do with practical considerations; I don't need to be
  practical, and he does.  THIS is precisely where I am deviating in
  my further development of this.

  What I (Tony) am currently thinking about is to pay a penalty
  initially (and maybe for a while!) on speed of access and write a
  general interface using a range of possible back-ends.  So that we
  can get the interface clean: xref pulls out a value and puts it int
  an array of the same structure, xref* pulls out a value and sticks
  it into a lisp array or scalar and returns it.  Speed can be handled
  later by doing a compile-time/run-time tradeoff, we will pay the
  compile-time penalty, in exchange for run-time advantages.  This
  fits into the theme of rapid prototyping (slow exec) with rapid
  execution (post-proto...).

  We'll optimize for version 2.  Ha-ha.

  Current thinking on the above, is to stick them into separate
  packages.  In particular, I've factored out the listoflist
  infrastructure into its own package.

  Checking current test state; but this is currently broken!
#+begin_src common-lisp
  (in-package :xarray-ut)
  (run-tests :suite 'xarray-ut)
  ;; => #<Results for XARRAY-UT 13 Tests, 0 Errors, 0 Failures>
  (describe (run-tests :suite 'xarray-ut))
#+end_src

** Development work and examples
   Here are any current trials that are undergoing development.
#+begin_src
(in-package :xarray-user)
;; and dev code goes here.
#+end_src

* Disserata and Footnotes

  [1] The slice interface is similar to Tamas' affi package, but now
  arbitrary index vectors are allowed, much like R.
